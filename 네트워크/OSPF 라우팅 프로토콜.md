## OSPF 라우팅 프로토콜
OSPF는 IP패킷안에 프로토콜 넘버89로 들어가게 된다. OSPF는 어떤 변화가 생길 때 바로 전달이 가능하기 때문에 컨버전스 타임이 훨씬 빠르다. 따라서 큰 네트워크에 적당함.   
OSPF는 Area라는 개념을 사용해 전체 OSPF 네트워크를 작은 영역으로 나누어 관리하기 때문에 빠른 업데이트를 하면서도 효율적인 관리가 가능함.  
OSPF는 VLSM을 확실하게 지원함. VLSM을 지원하게 되면 IP주소를 효과적으로 사용할 수 있다는 장점뿐만 아니라 라우팅 테이블을 줄이는 부수적인 효과도 있음.  
(VLSM이란? Variable Length Subnet Mask/ 서로 다른 서브넷에서 동일한 네트워크 번호로 다른 서브넷 마스크를 지정할 수 있는 특성. 한 라우터의 인터페이스들이 서로 다른 서브넷 마스크를 갖는 것. VLSM은 가용 주소 공간을 최적화하는데 도움이 된다.). 
이를 위해 OSPF는 라우트 서머리제이션(Route Summarization)을 지원하기 때문에 여러 개의 라우팅 경로를 하나로 묶어주는 기능이 탁월하다.  
(Route Summarization/ 경로 요약, 연속된 IP경로 정보들을 소유하고 있는라우터가 이를 축약된 형태로 경로 정보로 변환하여 전달할 수 있는 기법으로 슈퍼네팅, 루트 어그리게이션이라고도 함.). 
OSPF는 네트워크 크기에 대한 제한이 없다. 또 네트워크 대역폭 측면에서도 네트워크에 변화가 있을 때만 정보가 멀티캐스트로 날아가기 때문에 훨씬 실용적이다.  
OSPF는 많은 관련 요소를 합쳐서 경로를 선택하기 때문에 훨씬 정확한 경로 선택이 가능하다.  
OSPF는 표준 라우팅 프로토콜이고, 링크스테이트 라우팅 알고리즘이다.  

### OSPF가 적용되는 토폴로지(Topology)가 무엇인지 알아보자.
(토폴로지는 컴퓨터 네트워크의 요소들을 물리적으로 연결해 놓은 것. 또는 그 연결 방식을 의미.)  
일반적으로 다른 라우팅 프로토콜의 경우는 토폴로지를 별로 따지지 않지만 OSPF는 토폴로지가 바뀌는 것에 따라 약간씩 동작이 바뀌기 때문에 기본을 이해하는 것이 중요.  
* 브로드캐스트 멀티액세스 토폴로지  
네트워크에 두 개 이상의 라우터가 연결되는 경우로 하나의 메시지를 내보내면 이 네트워크 상에 있는 모든 녀석들이 정보를 받아볼 수 있는 구조. ex) 이더넷 세그먼트  
* 포인트 투 포인트 토폴로지 
네트워크에 한 쌍의 라우터만 존재하는 경우. ex) 전용선  
* NBMA(Non Broadcast Multi-access)  
네트워크에 두 개 이상의 라우터가 연결된다. 하지만 브로드캐스트 멀티액세스와는 다르게 브로드캐스트 능력은 가지고 있지 않다. ex) 프레임릴레이,X.25 네트워크  

### OSPF가 다른 OSPF 라우터들과 어떻게 교류하는지?
원래 OSPF에서 라우터는 주위에 있는 OSPF 라우터들을 찾아서 자신의 데이터베이스 안에 저장하는데, 이런 주위의 라우터들을 Neighbor(이웃)이라고 한다. 즉, 주변에 어떤 이웃이 사는지에 대한 정보를 관리하는 것. 이렇게 이웃을 찾아내기 위해 OSPF 라우터는 Hello 패킷을 내보낸다.  
라우터 A가 켜지면서 hello 메시지를 내보냄. 이 때 라우터 ID(OSPF에서 서로를 구분하는 이름/이 라우터의 IP 주소 중 제일 높은 주소를 사용)가 같이 나간다. 이웃이 누구인지 모르기 때문에 모든 OSPF 라우터들에게 헬로 패킷을 보내는데, 브로드캐스트로 보내는 것이 아니라, 멀티캐스트 주소를 이용해서 헬로를 보낸다.  
헬로를 받은 다른 라우터들은 라우터 A를 자신들의 이웃목록에 넣게 되는데 이 과정을 Init 과정이라고 함.  
헬로 메시지를 받은 OSPF 라우터들이 A에게 유니캐스트로 자신의 정보를 보내게 됨.  
A는 Neighbor들로부터 받은 정보를 자신의 Neighbor리스트에 넣어 관리함.   
헬로 패킷에는 라우터 ID와 DR, BDR을 결정하기 위한 Priority 필드들이 보이는데, 글자 뒤에 *모양이 있는데 이 별모양으로 표시된 것끼리 똑같아야 이웃으로 인정해줌.  

Neighbor 관계가 형성되어야 비로소 통신을 시작할 수 있음. 또 이런 이웃 관계 형성을 위해 헬로 패킷이 사용되는데, 이 패킷은 10초에 한 번씩 발생하고, 헬로 패킷에는 이웃이 되기 위해 꼭 일치해야하는 정보가 있음. 헬로 패킷을 4번 보내도 응답이 없으면 죽었다고 생각함. 그래서 데드 인터벌은 헬로의 4배가 됨.  

라우터 ID를 쓰기 위해서는 보통 Loopback(루프백) 인터페이스를 사용함. OSPF에서 루프백 인터페이스를 사용하면 그 IP 주소의 높낮이에 관계 없이 무조건 루프백 주소가 라우터 ID가 된다. 또 루프백 인터페이스가 다운되는 인터페이스가 아니기 때문에 라우터 ID가 바뀔 염려도 없다.  
(루프백 인터페이스란? 물리적으로 연결하는 포트가 존재하지 않는 논리적인 포트이다. 테스트 등을 목적으로 네트워크를 추가 시 사용할 수 있는 인터페이스이다.)  

OSPF 세그먼트에서는 각 라우터들이 OSPF에 참여하게 되면 DR과 BDR에게 자신의 Link State를 알리게 된다.  
이렇게 DR과 BDR에게만 자신의 링크 정보를 알리는 이유는 모든 라우터들과 Link State를 교환할 경우 발생하는 트래픽을 줄이고 Link State의 Sync를 제대로 관리하기 위해서이다.  
이 정보를 전달받은 DR은 이 정보를 모두 관리하면서 링크의 상태를 항상 일치시키는 역할을 하게된다.  
BDR은 DR이 업무를 제대로 수행하는지를 관찰하고, DR 라우터가 다운되면 바로 DR의 역할을 하게 된다.  
OSPF에서는 모든 라우터가 반드시 DR,BDR과 Link state를 Sync(일치)해야 한다. 이를 Adjacency라고 한다.  
DR과 BDR은 라우터 ID와 라우터의 Priority를 가지고 선출된다.  

### DR과 BDR의 선출과정?
OSPF에서 DR이 되기 위해서는 Priority가 높아야 함. OSPF로 동작하는 라우터들은 모두 Priority를 갖는데 이 값이 디폴트로 1이다. 만약 Priority 값이 같으면 라우터 ID가 높은 것이 DR이 된다.  
이미 DR과 BDR이 선출된 후 새로운 라우터가 들어오더라도 변경되지 않고, 만약 DR이 다운이 된다면 BDR이 DR이 되고, 그 다음 높은 라우터가 BDR이 된다.  
만약 라우터 전부가 전원이 꺼졌다 켜지면  DR/BDR 선거를 다시 하게 되므로 제일 높은 라우터가 DR이 된다.  
어떤 라우터를 DR/BDR이 되지 않게 하기 위해서는 Priority를 0으로 세팅하면 됨.  

* *와일드카드 마스크 ?* 서브넷 마스크의 반대 개념으로 서브넷 마스크에서 1인 부분을 모두 0으로, 0인 부분을 모두 1로 바꾼 것을 말함.

* *Area ?* 이는 OSPF에서는 보다 확장성 있는 라우팅 업데이트를 위해서 사용하는 개념으로, 전체 OSPF 영역을 보다 작은 area 단위로 나누어 그 영역 안에 있는 OSPF 라우터들끼리만 우선 링크 정보를 업데이트하고, 다른 area와의 통신은 area 사이에 있는 라우터들(ABR/Area Border Router)이 정보를 전달하도록 하는 방식.
OSPF가 area라는 단위로 나누어져 통신이 일어나고, area의 가장 기본은 백본 area라 불리는 area 0이다.
area를 구성할 때 백본 area를 중심으로 다른 area를 구성해 주는 것이 가장 일반적이다.

* 포인트 투 포인트인 경우 DR과 BDR을 선출 하지 않음. 왜냐하면 2개밖에 없기 때문에
